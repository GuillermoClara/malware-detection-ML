import numpy as np
import pandas as pd

import tkinter as tk
from tkinter import filedialog
import os
import FileParser as parser
import random

import sklearn.model_selection as md
from sklearn.metrics import accuracy_score, confusion_matrix, precision_score, f1_score, recall_score

import Preprocessor as pp

from ModelAnalyzers import analyzer_parsed_files

import warnings

########################################################################################################################
#   ______    _              _____             _
#  |  ____|  | |            |  __ \           (_)
#  | |__   __| | __ _  ___  | |  | | _____   ___  ___ ___
#  |  __| / _` |/ _` |/ _ \ | |  | |/ _ \ \ / / |/ __/ _ \
#  | |___| (_| | (_| |  __/ | |__| |  __/\ V /| | (_|  __/
#  |______\__,_|\__, |\___| |_____/ \___| \_/ |_|\___\___|
#                __/ |
#               |___/
# Class for Federated Learning edge devices
########################################################################################################################


class EdgeDevice:
    federated_server = None

    def __init__(self, federated_server, test_data):
        self.benign_amount = None
        self.malware_amount = None
        self.federated_server = federated_server
        self.local_model = None
        self.local_data = None

        self.id = random.randint(1, 1780)
        self.metrics_per_iteration = []

        self.testing_set = test_data

        self.test_x = test_data.drop('type', axis=1)
        self.test_y = test_data['type']

        self.analyzed_files = []


########################################################################################################################
# INITIALIZATION METHODS
########################################################################################################################

    def init_data(self, dataset, malw_amount, ben_amount):
        """
        Method used to assign data during the original dataset partition process

        :param dataset: pandas Dataframe
        :param malw_amount: Amount of malware samples in assigned dataset
        :param ben_amount: Amount of benign samples in assigned dataset
        """

        self.local_data = dataset
        self.malware_amount = malw_amount
        self.benign_amount = ben_amount

    def device_menu(self):

        finish = False

        while not finish:
            print('')
            print('DEVICE #', self.id)
            print('================')
            print('(1) Local data stats')
            print('(2) Local model metrics')
            print('(3) Test additional dataset')
            print('(4) Diagnose files')
            print('(5) Return to Federated Server Menu')

            option = input('Enter an option: ') or 5

            # Unexpected input handling
            if not pp.is_number(option):
                option = 5
            option = int(option)

            if option == 1:
                print('')
                print('Showing data statistics...')
                size = len(self.local_data)
                print('Local data total size:', size)
                malw_prop = len(self.local_data[self.local_data['type'] == 'Malicious'])
                ben_prop = len(self.local_data[self.local_data['type'] == 'Benign'])
                print('Malware samples:',malw_prop)
                print('Benign samples:', ben_prop)
                print('')
                print(self.local_data)
                print('')

            elif option == 2:
                print('')
                print('Showing model metrics')
                for metric in self.metrics_per_iteration:
                    print('Iteration #', metric['iteration'])
                    print('Accuracy', metric['accuracy'])
                    print('Recall', metric['recall'])
                    print('Precision', metric['precision'])
                    print('')

            elif option == 3:
                print('')
                print('Testing model with additional dataset')
                self.predict_testing_data()
                print('')

            elif option == 4:
                self.diagnose_files()
            else:
                finish = True

    def initial_train(self):
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            train_x = self.local_data.drop('type', axis=1)
            train_y = self.local_data['type']
            self.local_model.fit(train_x, train_y)

    def train(self, iteration=1):

        train_x = self.local_data.drop('type', axis=1)
        train_y = self.local_data['type']

        self.local_model.fit(train_x, train_y)

        prediction = self.local_model.predict(self.test_x)

        # Metric collection
        metric_info = dict()
        metric_info['accuracy'] = accuracy_score(self.test_y, prediction)
        metric_info['recall'] = recall_score(self.test_y, prediction, pos_label='Malicious')
        metric_info['precision'] = precision_score(self.test_y, prediction, pos_label='Malicious')
        metric_info['iteration'] = iteration
        self.metrics_per_iteration.append(metric_info)

    def predict_testing_data(self):

        predictors = self.testing_set.drop('type', axis=1)
        target = self.testing_set['type']

        train_x, test_x, train_y, test_y = md.train_test_split(predictors, target, train_size=0.75, test_size=0.25,
                                                               random_state=42)

        prediction = self.local_model.predict(test_x)

        print(confusion_matrix(test_y, prediction))
        print('Accuracy', accuracy_score(test_y, prediction))

    def predict(self, dataframe):
        return self.local_model.predict(dataframe)

    def diagnose_files(self):

        stop = False

        print('')
        print('YOU ARE NOW IN A SIMULATION OF A COMPUTER')
        print('=========================================')
        print('What do you want to do?')

        while stop is not True:

            files_to_examine = []

            print('Actions:')
            print('(1) Scan files')
            print('(2) Print results in chart')
            print('(3) Go back to Device Menu')
            option = str(input('Enter your option:') or '3').strip()

            match option:

                case '1':

                    root = tk.Tk()
                    root.withdraw()

                    print('Enter the type of files you expect to analyze in this round')
                    print('(e.g. Game, Windows, Third Party tools, etc) (default = Unknown)')
                    file_type = input('Enter the type: ') or 'Unknown'
                    print('Look for a file input window')

                    files_asked = filedialog.askopenfilenames(
                    initialdir=os.path.expanduser("~"),
                    filetypes=(('exe, dll', '*.exe;*.dll'),))

                    for filename in files_asked:
                        files_to_examine.append(os.path.abspath(filename))

                    if len(files_to_examine) == 0:
                        print('No file was submitted! Please try again')
                        continue

                    names_df, pefiles_df = parser.pefiles_to_dataset(files_to_examine)

                    predictions = self.predict(pefiles_df)

                    print('Predictions from the algorithm: ')
                    for name, prediction in zip(names_df, predictions):
                        print(name, ' - ', prediction)
                        self.analyzed_files.append({'filename': name, 'classified': prediction,
                                            'type': file_type,
                                            'model': 'Federated Logistic Regression'})

                case '2':
                    if len(self.analyzed_files) > 2:
                        analyzer_parsed_files(self.analyzed_files, 'Federated Logistic Regression')
                    else:
                        print('Too few analyzed files to create a chart (at least 3 needed)')

                case _:
                    stop = True

########################################################################################################################
#   _   _                            _   _____             _
#  | \ | |                          | | |  __ \           (_)
#  |  \| | ___  _ __ _ __ ___   __ _| | | |  | | _____   ___  ___ ___
#  | . ` |/ _ \| '__| '_ ` _ \ / _` | | | |  | |/ _ \ \ / / |/ __/ _ \
#  | |\  | (_) | |  | | | | | | (_| | | | |__| |  __/\ V /| | (_|  __/
#  |_| \_|\___/|_|  |_| |_| |_|\__,_|_| |_____/ \___| \_/ |_|\___\___|
#
# Used to represent a computer that interacts with a central server in a
# centralized approach.
########################################################################################################################

class NormalDevice:

    # Server to connect
    CentralizedServer = None

    malware_samples = benign_samples = None

########################################################################################################################
# INITIALIZATION METHODS
########################################################################################################################

    def __init__(self, server, identifier=0):
        self.id = identifier

        self.analyzed_files = []

        self.CentralizedServer = server

    def load_samples(self):
        """Gets remainder of dataset to keep as test files if the user wants to
         Evaluate the model current accuracy"""

        self.malware_samples = self.CentralizedServer.malware_test
        self.benign_samples = self.CentralizedServer.benign_test

    def request(self, df):
        """Method used to request a prediction to the model in the central server"""

        prediction = self.CentralizedServer.predict_new(df)

        return prediction

    def diagnose_files(self):

        exit = False

        while not exit:

            files_to_examine = []

            print('Actions:')
            print('(1) Scan files')
            print('(2) Print results in chart')
            print('(3) Go back to Device Menu')
            option = int(input('Enter your option:') or 3)

            match option:

                case 1:

                    root = tk.Tk()
                    root.withdraw()

                    print('Enter the type of files you expect to analyze in this round')
                    print('(e.g. Game, Windows, Third Party tools, etc) (default = Unknown)')
                    file_type = input('Enter the type: ') or 'Unknown'
                    print('Look for a file input window')

                    files_asked = filedialog.askopenfilenames(
                        initialdir=os.path.expanduser("~"),
                        filetypes=(('exe, dll', '*.exe;*.dll'),))

                    for filename in files_asked:
                        files_to_examine.append(os.path.abspath(filename))

                    if len(files_to_examine) == 0:
                        print('No file was submitted! Please try again')
                        continue

                    names_df, pefiles_df = parser.pefiles_to_dataset(files_to_examine)

                    predictions = self.request(pefiles_df)

                    print('Predictions from the algorithm: ')
                    for name, prediction in zip(names_df, predictions):
                        print(name, ' - ', prediction)
                        self.analyzed_files.append({'filename': name, 'classified': prediction,
                                                    'type': file_type,
                                                    'model': self.CentralizedServer.model_preference})

                case 2:
                    if len(self.analyzed_files) > 2:
                        analyzer_parsed_files(self.analyzed_files, self.CentralizedServer.model_preference)
                    else:
                        print('Too few analyzed files to create a chart (at least 3 needed)')

                case _:
                    exit = True


    def start_device_simulation(self):

        stop = False

        print('')
        print('YOU ARE NOW IN A SIMULATION OF A COMPUTER')
        print('=========================================')

        while stop is not True:

            print('')
            print('What do you want to do?')
            print('1. Diagnose files')
            print('2. Test preselected malware files')
            print('3. Test preselected benign files')
            print('4. Display model information and accuracy')

            if self.CentralizedServer.model_preference != 'Naive Bayes':
                print('5. Analyze how the model works with different parameters')
            else:
                print('5. Not available for GNB')

            print('6. End simulation')

            # Eval option
            option = (input('Enter option: ') or '10')
            print('')

            # Unexpected input handling
            if not pp.is_number(option):
                option = '10'
            option = int(option)

            match option:

                case 1:
                    self.diagnose_files()
                case 2:
                    prediction, truth, confusion_matrix, accuracy_score = self.CentralizedServer.predict(self.malware_samples)
                    print(confusion_matrix)
                    print(accuracy_score)
                case 3:
                    prediction, truth, confusion_matrix, accuracy_score = self.CentralizedServer.predict(self.benign_samples)
                    print(confusion_matrix)
                    print(accuracy_score)
                case 4:
                    self.CentralizedServer.get_stats()
                case 5:
                    self.CentralizedServer.run_analyzer()
                case 6:
                    return






